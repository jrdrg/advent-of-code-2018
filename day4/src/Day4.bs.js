// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var $$String = require("bs-platform/lib/js/string.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Input$Day4 = require("./Input.bs.js");
var Belt_MapInt = require("bs-platform/lib/js/belt_MapInt.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function parse(line) {
  var matches = line.match((/\[([\d-\s:]+)\]\s(.*)/));
  var list = $$Array.to_list(Belt_Option.getWithDefault(matches === null ? undefined : Caml_option.some(matches), /* array */[]));
  if (list) {
    var match = list[1];
    if (match) {
      var match$1 = match[1];
      if (match$1) {
        return /* tuple */[
                match[0],
                match$1[0]
              ];
      } else {
        return /* tuple */[
                "",
                ""
              ];
      }
    } else {
      return /* tuple */[
              "",
              ""
            ];
    }
  } else {
    return /* tuple */[
            "",
            ""
          ];
  }
}

function compareByTimestamp(param, param$1) {
  return $$String.compare(param[0], param$1[0]);
}

function sortByTimestamp(events) {
  $$Array.sort(compareByTimestamp, events);
  return events;
}

function getMinute(timestamp) {
  var matches = timestamp.match((/\d{2}:(\d{2})/));
  if (matches !== null && matches.length === 2) {
    return Caml_format.caml_int_of_string(matches[1]);
  } else {
    return 0;
  }
}

function updateGuardSleeping(guardId, minute, guardsSleeping) {
  return Belt_MapInt.update(guardsSleeping, guardId, (function (g) {
                if (g !== undefined) {
                  return Caml_option.some(Belt_MapInt.update(Caml_option.valFromOption(g), minute, (function (m) {
                                    return Belt_Option.getWithDefault(m, 0) + 1 | 0;
                                  })));
                } else {
                  return Caml_option.some(Belt_MapInt.set(Belt_MapInt.empty, minute, 1));
                }
              }));
}

function getGuardId(desc) {
  var matches = desc.match((/Guard #(\d+) begins shift/));
  if (matches !== null && matches.length === 2) {
    return Caml_format.caml_int_of_string(matches[1]);
  } else {
    return -1;
  }
}

function toEvent(param) {
  var desc = param[1];
  var timestamp = param[0];
  switch (desc) {
    case "falls asleep" : 
        return /* Asleep */Block.__(1, [getMinute(timestamp)]);
    case "wakes up" : 
        return /* Awake */Block.__(2, [getMinute(timestamp)]);
    default:
      return /* BeginShift */Block.__(0, [getGuardId(desc)]);
  }
}

function buildMap(param, $$event) {
  var guardsSleeping = param[2];
  var sleepMinute = param[1];
  var guardId = param[0];
  var match = toEvent($$event);
  switch (match.tag | 0) {
    case 0 : 
        return /* tuple */[
                match[0],
                0,
                guardsSleeping
              ];
    case 1 : 
        var minute = match[0];
        return /* tuple */[
                guardId,
                minute,
                updateGuardSleeping(guardId, minute, guardsSleeping)
              ];
    case 2 : 
        var minute$1 = match[0];
        var match$1 = sleepMinute > minute$1;
        var endMinute = match$1 ? minute$1 + 60 | 0 : minute$1;
        var updatedMap = $$Array.fold_left((function (map, min) {
                return updateGuardSleeping(guardId, min % 60, map);
              }), guardsSleeping, Belt_Array.range(sleepMinute, endMinute - 1 | 0));
        return /* tuple */[
                guardId,
                0,
                updatedMap
              ];
    
  }
}

var events = $$Array.map(parse, Input$Day4.input);

var match = $$Array.fold_left(buildMap, /* tuple */[
      0,
      0,
      Belt_MapInt.empty
    ], ($$Array.sort(compareByTimestamp, events), events));

var sleepMap = match[2];

var match$1 = Belt_MapInt.reduce(sleepMap, /* tuple */[
      0,
      0,
      0
    ], (function (param, guardId, minuteMap) {
        var sumMinutes = param[2];
        var match = Belt_MapInt.reduce(minuteMap, /* tuple */[
              0,
              0,
              0
            ], (function (param, min, timesAsleep) {
                var maxTimesAsleep = param[2];
                var sum = param[0];
                if (timesAsleep > maxTimesAsleep) {
                  return /* tuple */[
                          sum + timesAsleep | 0,
                          min,
                          timesAsleep
                        ];
                } else {
                  return /* tuple */[
                          sum + timesAsleep | 0,
                          param[1],
                          maxTimesAsleep
                        ];
                }
              }));
        var sum = match[0];
        if (sum > sumMinutes) {
          return /* tuple */[
                  guardId,
                  match[1],
                  sum
                ];
        } else {
          return /* tuple */[
                  param[0],
                  param[1],
                  sumMinutes
                ];
        }
      }));

var mostAsleepMinute = match$1[1];

var maxGuardId = match$1[0];

console.log("Part 1:", maxGuardId, mostAsleepMinute, Caml_int32.imul(maxGuardId, mostAsleepMinute));

var match$2 = Belt_MapInt.reduce(sleepMap, /* tuple */[
      0,
      0,
      0
    ], (function (param, guardId, minuteMap) {
        var highestFrequency = param[2];
        var match = Belt_MapInt.reduce(minuteMap, /* tuple */[
              0,
              0
            ], (function (param, min, timesAsleep) {
                var maxCount = param[1];
                if (timesAsleep > maxCount) {
                  return /* tuple */[
                          min,
                          timesAsleep
                        ];
                } else {
                  return /* tuple */[
                          param[0],
                          maxCount
                        ];
                }
              }));
        var freq = match[1];
        if (freq > highestFrequency) {
          return /* tuple */[
                  guardId,
                  match[0],
                  freq
                ];
        } else {
          return /* tuple */[
                  param[0],
                  param[1],
                  highestFrequency
                ];
        }
      }));

var mostFrequentMinute = match$2[1];

var guardId = match$2[0];

console.log("Part 2:", guardId, mostFrequentMinute, Caml_int32.imul(guardId, mostFrequentMinute));

exports.parse = parse;
exports.compareByTimestamp = compareByTimestamp;
exports.sortByTimestamp = sortByTimestamp;
exports.getMinute = getMinute;
exports.updateGuardSleeping = updateGuardSleeping;
exports.getGuardId = getGuardId;
exports.toEvent = toEvent;
exports.buildMap = buildMap;
exports.sleepMap = sleepMap;
exports.maxGuardId = maxGuardId;
exports.mostAsleepMinute = mostAsleepMinute;
exports.guardId = guardId;
exports.mostFrequentMinute = mostFrequentMinute;
/* match Not a pure module */
